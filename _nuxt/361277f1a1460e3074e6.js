(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{203:function(e,n){e.exports={body:'<h2>Worum geht\'s?</h2><br />\nTesten von Software und das sicherstellen von korrekter Software in Bezug auf den Anforderungen und Anwendungsf&auml;llen. Um dieses Ziel zu erreichen, m&ouml;chte man nicht zu wenig, aber auch nicht zu viel Testen. Zu viel Tests w&uuml;rden das Testbudged strapazieren, zu wenige k&ouml;nnten die Qualit&auml;t der Software reduzieren.<br />\nDeshalb werden beim Testen von Methoden generell zwei Verfahren angewendet, um die Testdatenmenge zu reduzieren.</p>\n<ol>\n<li>&Auml;quivalenzklassen auf den Inputdefinitionsbereichen werden gebildet.<br />\nBsp.: Eingabefeld Hausnummer wird aufgeteilt in g&uuml;ltige Eingaben den Integerwerten gr&ouml;&szlig;er 0, den ung&uuml;ltigen kleiner gleich 0 und den restlichen ung&uuml;ltigen Eingabem&ouml;glichkeiten.</li></p>\n<li>Um nicht alle &Auml;quivalenzklassen-Kombinationen bei mehreren Inputparametern testen zu m&uuml;ssen wird auf die <a title="Pairwise-Methode auf Wikipedia" href="http://de.wikipedia.org/wiki/Pairwise-Methode" target="_blank">Pairwise-Methode</a> zur&uuml;ckgegriffen. Es werden dabei nur alle Eingabeparameter paarweise kombiniert anstelle des Kreuzproduktes.</li><br />\n</ol><br />\n<a id="more"></a><a id="more-19"></a>\n<h2>Anwendungsfall</h2><br />\nBei einer neu programmierten Anwendung soll ein Systemtest durchgef&uuml;hrt werden, wobei mehrere spezifizierte Anwendungsf&auml;lle durchgepr&uuml;ft werden sollen; beispielsweise das Suchen nach einer Zugverbindung Berlin - Hamburg.</p>\n<h2>Problem</h2><br />\nBei Tests auf Anwendungsfallebene bleiben trotz &Auml;quivalenzklassenbildung und Anwendung der Pairwise-Methode f&uuml;r die Kombinationen sehr viele verschiedene Testf&auml;lle &uuml;brig, da oftmals sehr viele Eingabeparameter f&uuml;r den Benutzer existieren (beispielsweise schon bei der Suche einer Zugverbindung). Die Frage ist, ob diese zum einen sinnvoll sind und zum anderen ob sie f&uuml;r eine ausreichende Testabdeckung notwendig sind.</p>\n<p>F&uuml;hrt man das geschilderte Vorgehen in der Praxis aus, fallen zwei Dinge auf:</p>\n<ol>\n<li>Da die &Auml;quivalenzklassen auch Fehlerf&auml;lle widerspiegeln, kann es passieren, dass nachdem man die verschiedenen Inputvariablen mit der Pairwise-Methode kombiniert hat, keine Kombination den "Standardfall" wiedergibt; d. h. alle Kombinationen enthalten Eingabedaten, die zwangsl&auml;ufig einen Fehlerfall &uuml;berpr&uuml;fen.</li>\n<li>Wenn man einen Systemtest durchf&uuml;hrt sind meist viel mehr Eingabeparameter zu ber&uuml;cksichtigen als dies bei Methoden mit oftmals verh&auml;ltnism&auml;&szlig;ig wenig Eingabeparametern der Fall ist. Folglich entstehen trotz den vorgeschlagenen Ma&szlig;nahmen sehr viele Testkombinationsf&auml;lle.</li><br />\n</ol>\n<h2>L&ouml;sung</h2><br />\nEine L&ouml;sung k&ouml;nnte das bilden von logischen Eingabeeinheiten sein, sodass nicht mehr alle Eingabefelder per se paarweise kombiniert werden, sondern nur noch die logischen Einheiten. Ein Verfahren, dass ich selbst praktisch angewendet habe, kann folgenderma&szlig;en skizziert werden:</p>\n<ol>\n<li>Schritt: Bildung von &Auml;quivalenzklassen auf Definitionsbereich der Eingabevariablen:<br />\nEingabevariablendefinitionsbereich &rarr; Aequivalenzklassen; Bsp.:<br />\n<code>a<sub>1</sub> &isin; $$\\mathbb{N}$$ &rarr; aA<sub>1</sub> = { M<sub>f</sub> = { intMin, .. ,0 }, N<sub>p</sub> = {1, .. , 43 }, O<sub>f</sub> = {44, .. , maxInt}}<br />\na<sub>2</sub> .. a<sub>n</sub> &rarr; aA<sub>2</sub>, .. , aA<sub>n</sub></code></li></p>\n<li>Schritt: Bildung von logischen Einheiten auf den verschiedenen Eingabevariablen:<br />\nEingabevariablen &rarr; logische Einheit; Bsp.:<br />\n<code>a<sub>1</sub>, a<sub>2</sub>, .. , a<sub>n</sub> &rarr; b<sub>1</sub> = {a<sub>1</sub>, a<sub>3</sub>, a<sub>4</sub>} und b<sub>2</sub> = {a<sub>2</sub>, a<sub>5</sub>} usw.</code></li></p>\n<li>Clustering der &Auml;quivalenzklassen pro logische Einheit<br />\n&Auml;quivalenzklassen pro logische Einheit &rarr; aggregierte &Auml;quivalenzklassen pro logische Einheit<br />\n<code>bA<sub>1</sub> = {aA<sub>1</sub>, aA<sub>3</sub>, aA<sub>4</sub>} &hArr; {M<sub>f</sub>, N<sub>p</sub>, O<sub>f</sub>, ...} &rarr; BA<sub>1</sub> = {P, F<sub>1</sub>, F<sub>2</sub>}</code><br />\nWobei <sub>p</sub> Pass und <sub>f</sub> Fail bedeuteut.</li><br />\n</ol><br />\nBeispiel: Man hat eine Eingabemaske zu einer Person; (1) Dann kann man zu jedem Eingabefeld eine &Auml;quivalenzklasse bilden. (2) Anschlie&szlig;end aggregiert man die Felder (z.B. Heimadressfelder, Arbeitsadressfelder, Angaben zur Krankenkasse usw.) und (3) abschlie&szlig;end kombiniert man die &Auml;quivalenzklassen der aggregierten Felder.</p>\n<p>Ergebnis: logische Einheiten mit aggrebierten &Auml;quivalenzklassen.</p>\n<p>In den von mir eingesetzten F&auml;llen reduzieren sich die Eingabetestf&auml;lle erheblich. Zudem entstehen auch beim paarweisen kombinieren weiterhin Standardtestf&auml;lle. &Uuml;ber die Testqualit&auml;t kann ich nur eine Annahme treffen. Ich w&uuml;rde aber behaupten, dass diese nicht signifikant sinkt, denn:</p>\n<ol>\n<li>die logischen Einheiten bilden meist auch Subsysteme ab und diese sollten vorab von Subsystemtests getestet werden. Die Integration wird aber weiterhin durch die Kombinationen der logischen Einheiten getestet.</li>\n<li>weiterhin werden Randf&auml;lle betrachtet und die Kombination daraus getestet. Auf einer logischen Ebene handelt es sich also um &Auml;quivalenzklassen bei den Aggregationen.</li><br />\n</ol><br />\nFalls ihr anderer Meinung seid, lasst es mich wissen. Ansonsten viel Erfolg beim Softwaretesten!\n',html:'<h2>Worum geht\'s?</h2><br />\nTesten von Software und das sicherstellen von korrekter Software in Bezug auf den Anforderungen und Anwendungsf&auml;llen. Um dieses Ziel zu erreichen, m&ouml;chte man nicht zu wenig, aber auch nicht zu viel Testen. Zu viel Tests w&uuml;rden das Testbudged strapazieren, zu wenige k&ouml;nnten die Qualit&auml;t der Software reduzieren.<br />\nDeshalb werden beim Testen von Methoden generell zwei Verfahren angewendet, um die Testdatenmenge zu reduzieren.</p>\n<ol>\n<li>&Auml;quivalenzklassen auf den Inputdefinitionsbereichen werden gebildet.<br />\nBsp.: Eingabefeld Hausnummer wird aufgeteilt in g&uuml;ltige Eingaben den Integerwerten gr&ouml;&szlig;er 0, den ung&uuml;ltigen kleiner gleich 0 und den restlichen ung&uuml;ltigen Eingabem&ouml;glichkeiten.</li></p>\n<li>Um nicht alle &Auml;quivalenzklassen-Kombinationen bei mehreren Inputparametern testen zu m&uuml;ssen wird auf die <a title="Pairwise-Methode auf Wikipedia" href="http://de.wikipedia.org/wiki/Pairwise-Methode" target="_blank">Pairwise-Methode</a> zur&uuml;ckgegriffen. Es werden dabei nur alle Eingabeparameter paarweise kombiniert anstelle des Kreuzproduktes.</li><br />\n</ol><br />\n<a id="more"></a><a id="more-19"></a>\n<h2>Anwendungsfall</h2><br />\nBei einer neu programmierten Anwendung soll ein Systemtest durchgef&uuml;hrt werden, wobei mehrere spezifizierte Anwendungsf&auml;lle durchgepr&uuml;ft werden sollen; beispielsweise das Suchen nach einer Zugverbindung Berlin - Hamburg.</p>\n<h2>Problem</h2><br />\nBei Tests auf Anwendungsfallebene bleiben trotz &Auml;quivalenzklassenbildung und Anwendung der Pairwise-Methode f&uuml;r die Kombinationen sehr viele verschiedene Testf&auml;lle &uuml;brig, da oftmals sehr viele Eingabeparameter f&uuml;r den Benutzer existieren (beispielsweise schon bei der Suche einer Zugverbindung). Die Frage ist, ob diese zum einen sinnvoll sind und zum anderen ob sie f&uuml;r eine ausreichende Testabdeckung notwendig sind.</p>\n<p>F&uuml;hrt man das geschilderte Vorgehen in der Praxis aus, fallen zwei Dinge auf:</p>\n<ol>\n<li>Da die &Auml;quivalenzklassen auch Fehlerf&auml;lle widerspiegeln, kann es passieren, dass nachdem man die verschiedenen Inputvariablen mit der Pairwise-Methode kombiniert hat, keine Kombination den "Standardfall" wiedergibt; d. h. alle Kombinationen enthalten Eingabedaten, die zwangsl&auml;ufig einen Fehlerfall &uuml;berpr&uuml;fen.</li>\n<li>Wenn man einen Systemtest durchf&uuml;hrt sind meist viel mehr Eingabeparameter zu ber&uuml;cksichtigen als dies bei Methoden mit oftmals verh&auml;ltnism&auml;&szlig;ig wenig Eingabeparametern der Fall ist. Folglich entstehen trotz den vorgeschlagenen Ma&szlig;nahmen sehr viele Testkombinationsf&auml;lle.</li><br />\n</ol>\n<h2>L&ouml;sung</h2><br />\nEine L&ouml;sung k&ouml;nnte das bilden von logischen Eingabeeinheiten sein, sodass nicht mehr alle Eingabefelder per se paarweise kombiniert werden, sondern nur noch die logischen Einheiten. Ein Verfahren, dass ich selbst praktisch angewendet habe, kann folgenderma&szlig;en skizziert werden:</p>\n<ol>\n<li>Schritt: Bildung von &Auml;quivalenzklassen auf Definitionsbereich der Eingabevariablen:<br />\nEingabevariablendefinitionsbereich &rarr; Aequivalenzklassen; Bsp.:<br />\n<code>a<sub>1</sub> &isin; $$\\mathbb{N}$$ &rarr; aA<sub>1</sub> = { M<sub>f</sub> = { intMin, .. ,0 }, N<sub>p</sub> = {1, .. , 43 }, O<sub>f</sub> = {44, .. , maxInt}}<br />\na<sub>2</sub> .. a<sub>n</sub> &rarr; aA<sub>2</sub>, .. , aA<sub>n</sub></code></li></p>\n<li>Schritt: Bildung von logischen Einheiten auf den verschiedenen Eingabevariablen:<br />\nEingabevariablen &rarr; logische Einheit; Bsp.:<br />\n<code>a<sub>1</sub>, a<sub>2</sub>, .. , a<sub>n</sub> &rarr; b<sub>1</sub> = {a<sub>1</sub>, a<sub>3</sub>, a<sub>4</sub>} und b<sub>2</sub> = {a<sub>2</sub>, a<sub>5</sub>} usw.</code></li></p>\n<li>Clustering der &Auml;quivalenzklassen pro logische Einheit<br />\n&Auml;quivalenzklassen pro logische Einheit &rarr; aggregierte &Auml;quivalenzklassen pro logische Einheit<br />\n<code>bA<sub>1</sub> = {aA<sub>1</sub>, aA<sub>3</sub>, aA<sub>4</sub>} &hArr; {M<sub>f</sub>, N<sub>p</sub>, O<sub>f</sub>, ...} &rarr; BA<sub>1</sub> = {P, F<sub>1</sub>, F<sub>2</sub>}</code><br />\nWobei <sub>p</sub> Pass und <sub>f</sub> Fail bedeuteut.</li><br />\n</ol><br />\nBeispiel: Man hat eine Eingabemaske zu einer Person; (1) Dann kann man zu jedem Eingabefeld eine &Auml;quivalenzklasse bilden. (2) Anschlie&szlig;end aggregiert man die Felder (z.B. Heimadressfelder, Arbeitsadressfelder, Angaben zur Krankenkasse usw.) und (3) abschlie&szlig;end kombiniert man die &Auml;quivalenzklassen der aggregierten Felder.</p>\n<p>Ergebnis: logische Einheiten mit aggrebierten &Auml;quivalenzklassen.</p>\n<p>In den von mir eingesetzten F&auml;llen reduzieren sich die Eingabetestf&auml;lle erheblich. Zudem entstehen auch beim paarweisen kombinieren weiterhin Standardtestf&auml;lle. &Uuml;ber die Testqualit&auml;t kann ich nur eine Annahme treffen. Ich w&uuml;rde aber behaupten, dass diese nicht signifikant sinkt, denn:</p>\n<ol>\n<li>die logischen Einheiten bilden meist auch Subsysteme ab und diese sollten vorab von Subsystemtests getestet werden. Die Integration wird aber weiterhin durch die Kombinationen der logischen Einheiten getestet.</li>\n<li>weiterhin werden Randf&auml;lle betrachtet und die Kombination daraus getestet. Auf einer logischen Ebene handelt es sich also um &Auml;quivalenzklassen bei den Aggregationen.</li><br />\n</ol><br />\nFalls ihr anderer Meinung seid, lasst es mich wissen. Ansonsten viel Erfolg beim Softwaretesten!\n',attributes:{layout:"post",status:"publish",published:!0,title:"Anwendung der Pairwise-Methode für Eingaben auf Use Case-Ebene",author:"Simon Dittlmann",author_login:"Simon",author_email:"simon.dittlmann@itnotes.de",author_url:"http://www.itnotes.de",excerpt:'<h2>Worum geht\'s?</h2>\r\nTesten von Software und das sicherstellen von korrekter Software in Bezug auf den Anforderungen und Anwendungsf&auml;llen. Um dieses Ziel zu erreichen, m&ouml;chte man nicht zu wenig, aber auch nicht zu viel Testen. Zu viel Tests w&uuml;rden das Testbudged strapazieren, zu wenige k&ouml;nnten die Qualit&auml;t der Software reduzieren.\r\nDeshalb werden beim Testen von Methoden generell zwei Verfahren angewendet, um die Testdatenmenge zu reduzieren.\r\n<ol>\r\n\t<li>&Auml;quivalenzklassen auf den Inputdefinitionsbereichen werden gebildet.\r\nBsp.: Eingabefeld Hausnummer wird aufgeteilt in g&uuml;ltige Eingaben den Integerwerten gr&ouml;&szlig;er 0, den ung&uuml;ltigen kleiner gleich 0 und den restlichen ung&uuml;ltigen Eingabem&ouml;glichkeiten.</li>\r\n\t<li>Um nicht alle &Auml;quivalenzklassen-Kombinationen bei mehreren Inputparametern testen zu m&uuml;ssen wird auf die <a title="Pairwise-Methode auf Wikipedia" href="http://de.wikipedia.org/wiki/Pairwise-Methode" target="_blank">Pairwise-Methode</a> zur&uuml;ckgegriffen. Es werden dabei nur alle Eingabeparameter paarweise kombiniert anstelle des Kreuzproduktes.</li>\r\n</ol>\r\n',wordpress_id:19,wordpress_url:"http://www.pindarsign.de/itnotes/?p=19",date:"2009-07-14 09:24:25 +0200",date_gmt:"2009-07-14 07:24:25 +0200",categories:["articles"],tags:["pairwise","systemtest","methode"],comments:[{id:3,author:"Ben",author_email:"kontakt@benediktlang.de",author_url:"http://orangebud.net",date:"2009-07-24 10:04:13 +0200",date_gmt:"2009-07-24 08:04:13 +0200",content:"Sch&ouml;ner Artikel, ohne Wikiartikel h&auml;tte ich ihn allerdings nicht verstanden. Ich weiss dass es vielleicht nicht ins Konzept passt, aber ein wenig Programmcode w&auml;re genial um das ganze irgendwie ansatzweise in Aktion zu sehen (evtl zu lang, letztendlich versteht mans dann doch). Habe wieder etwas dazugelernt :) Danke"}],_meta:{resourcePath:"/home/travis/build/Pindar/itnotes/contents/posts/2009-07-14-anwendung-der-pairwise-methode-fur-eingaben-auf-use-case-ebene.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h2\',[_vm._v("Worum geht\'s?")]),_c(\'br\'),_vm._v("\\nTesten von Software und das sicherstellen von korrekter Software in Bezug auf den Anforderungen und Anwendungsfällen. Um dieses Ziel zu erreichen, möchte man nicht zu wenig, aber auch nicht zu viel Testen. Zu viel Tests würden das Testbudged strapazieren, zu wenige könnten die Qualität der Software reduzieren."),_c(\'br\'),_vm._v("\\nDeshalb werden beim Testen von Methoden generell zwei Verfahren angewendet, um die Testdatenmenge zu reduzieren."),_c(\'p\'),_vm._v(" "),_c(\'ol\',[_c(\'li\',[_vm._v("Äquivalenzklassen auf den Inputdefinitionsbereichen werden gebildet."),_c(\'br\'),_vm._v("\\nBsp.: Eingabefeld Hausnummer wird aufgeteilt in gültige Eingaben den Integerwerten größer 0, den ungültigen kleiner gleich 0 und den restlichen ungültigen Eingabemöglichkeiten.")]),_c(\'p\'),_vm._v(" "),_c(\'li\',[_vm._v("Um nicht alle Äquivalenzklassen-Kombinationen bei mehreren Inputparametern testen zu müssen wird auf die "),_c(\'a\',{attrs:{"title":"Pairwise-Methode auf Wikipedia","href":"http://de.wikipedia.org/wiki/Pairwise-Methode","target":"_blank"}},[_vm._v("Pairwise-Methode")]),_vm._v(" zurückgegriffen. Es werden dabei nur alle Eingabeparameter paarweise kombiniert anstelle des Kreuzproduktes.")]),_c(\'br\')]),_c(\'br\'),_vm._v(" "),_c(\'a\',{attrs:{"id":"more"}}),_c(\'a\',{attrs:{"id":"more-19"}}),_vm._v(" "),_c(\'h2\',[_vm._v("Anwendungsfall")]),_c(\'br\'),_vm._v("\\nBei einer neu programmierten Anwendung soll ein Systemtest durchgeführt werden, wobei mehrere spezifizierte Anwendungsfälle durchgeprüft werden sollen; beispielsweise das Suchen nach einer Zugverbindung Berlin - Hamburg."),_c(\'p\'),_vm._v(" "),_c(\'h2\',[_vm._v("Problem")]),_c(\'br\'),_vm._v("\\nBei Tests auf Anwendungsfallebene bleiben trotz Äquivalenzklassenbildung und Anwendung der Pairwise-Methode für die Kombinationen sehr viele verschiedene Testfälle übrig, da oftmals sehr viele Eingabeparameter für den Benutzer existieren (beispielsweise schon bei der Suche einer Zugverbindung). Die Frage ist, ob diese zum einen sinnvoll sind und zum anderen ob sie für eine ausreichende Testabdeckung notwendig sind."),_c(\'p\'),_vm._v(" "),_c(\'p\',[_vm._v("Führt man das geschilderte Vorgehen in der Praxis aus, fallen zwei Dinge auf:")]),_vm._v(" "),_c(\'ol\',[_c(\'li\',[_vm._v("Da die Äquivalenzklassen auch Fehlerfälle widerspiegeln, kann es passieren, dass nachdem man die verschiedenen Inputvariablen mit der Pairwise-Methode kombiniert hat, keine Kombination den \\"Standardfall\\" wiedergibt; d. h. alle Kombinationen enthalten Eingabedaten, die zwangsläufig einen Fehlerfall überprüfen.")]),_vm._v(" "),_c(\'li\',[_vm._v("Wenn man einen Systemtest durchführt sind meist viel mehr Eingabeparameter zu berücksichtigen als dies bei Methoden mit oftmals verhältnismäßig wenig Eingabeparametern der Fall ist. Folglich entstehen trotz den vorgeschlagenen Maßnahmen sehr viele Testkombinationsfälle.")]),_c(\'br\')]),_vm._v(" "),_c(\'h2\',[_vm._v("Lösung")]),_c(\'br\'),_vm._v("\\nEine Lösung könnte das bilden von logischen Eingabeeinheiten sein, sodass nicht mehr alle Eingabefelder per se paarweise kombiniert werden, sondern nur noch die logischen Einheiten. Ein Verfahren, dass ich selbst praktisch angewendet habe, kann folgendermaßen skizziert werden:"),_c(\'p\'),_vm._v(" "),_c(\'ol\',[_c(\'li\',[_vm._v("Schritt: Bildung von Äquivalenzklassen auf Definitionsbereich der Eingabevariablen:"),_c(\'br\'),_vm._v("\\nEingabevariablendefinitionsbereich → Aequivalenzklassen; Bsp.:"),_c(\'br\'),_vm._v(" "),_c(\'code\',{pre:true},[_vm._v("a"),_c(\'sub\',[_vm._v("1")]),_vm._v(" ∈ $$\\\\mathbb{N}$$ → aA"),_c(\'sub\',[_vm._v("1")]),_vm._v(" = { M"),_c(\'sub\',[_vm._v("f")]),_vm._v(" = { intMin, .. ,0 }, N"),_c(\'sub\',[_vm._v("p")]),_vm._v(" = {1, .. , 43 }, O"),_c(\'sub\',[_vm._v("f")]),_vm._v(" = {44, .. , maxInt}}"),_c(\'br\'),_vm._v("\\na"),_c(\'sub\',[_vm._v("2")]),_vm._v(" .. a"),_c(\'sub\',[_vm._v("n")]),_vm._v(" → aA"),_c(\'sub\',[_vm._v("2")]),_vm._v(", .. , aA"),_c(\'sub\',[_vm._v("n")])])]),_c(\'p\'),_vm._v(" "),_c(\'li\',[_vm._v("Schritt: Bildung von logischen Einheiten auf den verschiedenen Eingabevariablen:"),_c(\'br\'),_vm._v("\\nEingabevariablen → logische Einheit; Bsp.:"),_c(\'br\'),_vm._v(" "),_c(\'code\',{pre:true},[_vm._v("a"),_c(\'sub\',[_vm._v("1")]),_vm._v(", a"),_c(\'sub\',[_vm._v("2")]),_vm._v(", .. , a"),_c(\'sub\',[_vm._v("n")]),_vm._v(" → b"),_c(\'sub\',[_vm._v("1")]),_vm._v(" = {a"),_c(\'sub\',[_vm._v("1")]),_vm._v(", a"),_c(\'sub\',[_vm._v("3")]),_vm._v(", a"),_c(\'sub\',[_vm._v("4")]),_vm._v("} und b"),_c(\'sub\',[_vm._v("2")]),_vm._v(" = {a"),_c(\'sub\',[_vm._v("2")]),_vm._v(", a"),_c(\'sub\',[_vm._v("5")]),_vm._v("} usw.")])]),_c(\'p\'),_vm._v(" "),_c(\'li\',[_vm._v("Clustering der Äquivalenzklassen pro logische Einheit"),_c(\'br\'),_vm._v("\\nÄquivalenzklassen pro logische Einheit → aggregierte Äquivalenzklassen pro logische Einheit"),_c(\'br\'),_vm._v(" "),_c(\'code\',{pre:true},[_vm._v("bA"),_c(\'sub\',[_vm._v("1")]),_vm._v(" = {aA"),_c(\'sub\',[_vm._v("1")]),_vm._v(", aA"),_c(\'sub\',[_vm._v("3")]),_vm._v(", aA"),_c(\'sub\',[_vm._v("4")]),_vm._v("} ⇔ {M"),_c(\'sub\',[_vm._v("f")]),_vm._v(", N"),_c(\'sub\',[_vm._v("p")]),_vm._v(", O"),_c(\'sub\',[_vm._v("f")]),_vm._v(", ...} → BA"),_c(\'sub\',[_vm._v("1")]),_vm._v(" = {P, F"),_c(\'sub\',[_vm._v("1")]),_vm._v(", F"),_c(\'sub\',[_vm._v("2")]),_vm._v("}")]),_c(\'br\'),_vm._v("\\nWobei "),_c(\'sub\',[_vm._v("p")]),_vm._v(" Pass und "),_c(\'sub\',[_vm._v("f")]),_vm._v(" Fail bedeuteut.")]),_c(\'br\')]),_c(\'br\'),_vm._v("\\nBeispiel: Man hat eine Eingabemaske zu einer Person; (1) Dann kann man zu jedem Eingabefeld eine Äquivalenzklasse bilden. (2) Anschließend aggregiert man die Felder (z.B. Heimadressfelder, Arbeitsadressfelder, Angaben zur Krankenkasse usw.) und (3) abschließend kombiniert man die Äquivalenzklassen der aggregierten Felder."),_c(\'p\'),_vm._v(" "),_c(\'p\',[_vm._v("Ergebnis: logische Einheiten mit aggrebierten Äquivalenzklassen.")]),_vm._v(" "),_c(\'p\',[_vm._v("In den von mir eingesetzten Fällen reduzieren sich die Eingabetestfälle erheblich. Zudem entstehen auch beim paarweisen kombinieren weiterhin Standardtestfälle. Über die Testqualität kann ich nur eine Annahme treffen. Ich würde aber behaupten, dass diese nicht signifikant sinkt, denn:")]),_vm._v(" "),_c(\'ol\',[_c(\'li\',[_vm._v("die logischen Einheiten bilden meist auch Subsysteme ab und diese sollten vorab von Subsystemtests getestet werden. Die Integration wird aber weiterhin durch die Kombinationen der logischen Einheiten getestet.")]),_vm._v(" "),_c(\'li\',[_vm._v("weiterhin werden Randfälle betrachtet und die Kombination daraus getestet. Auf einer logischen Ebene handelt es sich also um Äquivalenzklassen bei den Aggregationen.")]),_c(\'br\')]),_c(\'br\'),_vm._v("\\nFalls ihr anderer Meinung seid, lasst es mich wissen. Ansonsten viel Erfolg beim Softwaretesten!\\n")]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"dynamicMarkdown"},[r("h2",[e._v("Worum geht's?")]),r("br"),e._v("\nTesten von Software und das sicherstellen von korrekter Software in Bezug auf den Anforderungen und Anwendungsfällen. Um dieses Ziel zu erreichen, möchte man nicht zu wenig, aber auch nicht zu viel Testen. Zu viel Tests würden das Testbudged strapazieren, zu wenige könnten die Qualität der Software reduzieren."),r("br"),e._v("\nDeshalb werden beim Testen von Methoden generell zwei Verfahren angewendet, um die Testdatenmenge zu reduzieren."),r("p"),e._v(" "),r("ol",[r("li",[e._v("Äquivalenzklassen auf den Inputdefinitionsbereichen werden gebildet."),r("br"),e._v("\nBsp.: Eingabefeld Hausnummer wird aufgeteilt in gültige Eingaben den Integerwerten größer 0, den ungültigen kleiner gleich 0 und den restlichen ungültigen Eingabemöglichkeiten.")]),r("p"),e._v(" "),r("li",[e._v("Um nicht alle Äquivalenzklassen-Kombinationen bei mehreren Inputparametern testen zu müssen wird auf die "),r("a",{attrs:{title:"Pairwise-Methode auf Wikipedia",href:"http://de.wikipedia.org/wiki/Pairwise-Methode",target:"_blank"}},[e._v("Pairwise-Methode")]),e._v(" zurückgegriffen. Es werden dabei nur alle Eingabeparameter paarweise kombiniert anstelle des Kreuzproduktes.")]),r("br")]),r("br"),e._v(" "),r("a",{attrs:{id:"more"}}),r("a",{attrs:{id:"more-19"}}),e._v(" "),r("h2",[e._v("Anwendungsfall")]),r("br"),e._v("\nBei einer neu programmierten Anwendung soll ein Systemtest durchgeführt werden, wobei mehrere spezifizierte Anwendungsfälle durchgeprüft werden sollen; beispielsweise das Suchen nach einer Zugverbindung Berlin - Hamburg."),r("p"),e._v(" "),r("h2",[e._v("Problem")]),r("br"),e._v("\nBei Tests auf Anwendungsfallebene bleiben trotz Äquivalenzklassenbildung und Anwendung der Pairwise-Methode für die Kombinationen sehr viele verschiedene Testfälle übrig, da oftmals sehr viele Eingabeparameter für den Benutzer existieren (beispielsweise schon bei der Suche einer Zugverbindung). Die Frage ist, ob diese zum einen sinnvoll sind und zum anderen ob sie für eine ausreichende Testabdeckung notwendig sind."),r("p"),e._v(" "),r("p",[e._v("Führt man das geschilderte Vorgehen in der Praxis aus, fallen zwei Dinge auf:")]),e._v(" "),r("ol",[r("li",[e._v('Da die Äquivalenzklassen auch Fehlerfälle widerspiegeln, kann es passieren, dass nachdem man die verschiedenen Inputvariablen mit der Pairwise-Methode kombiniert hat, keine Kombination den "Standardfall" wiedergibt; d. h. alle Kombinationen enthalten Eingabedaten, die zwangsläufig einen Fehlerfall überprüfen.')]),e._v(" "),r("li",[e._v("Wenn man einen Systemtest durchführt sind meist viel mehr Eingabeparameter zu berücksichtigen als dies bei Methoden mit oftmals verhältnismäßig wenig Eingabeparametern der Fall ist. Folglich entstehen trotz den vorgeschlagenen Maßnahmen sehr viele Testkombinationsfälle.")]),r("br")]),e._v(" "),r("h2",[e._v("Lösung")]),r("br"),e._v("\nEine Lösung könnte das bilden von logischen Eingabeeinheiten sein, sodass nicht mehr alle Eingabefelder per se paarweise kombiniert werden, sondern nur noch die logischen Einheiten. Ein Verfahren, dass ich selbst praktisch angewendet habe, kann folgendermaßen skizziert werden:"),r("p"),e._v(" "),r("ol",[r("li",[e._v("Schritt: Bildung von Äquivalenzklassen auf Definitionsbereich der Eingabevariablen:"),r("br"),e._v("\nEingabevariablendefinitionsbereich → Aequivalenzklassen; Bsp.:"),r("br"),e._v(" "),r("code",{pre:!0},[e._v("a"),r("sub",[e._v("1")]),e._v(" ∈ $$\\mathbb{N}$$ → aA"),r("sub",[e._v("1")]),e._v(" = { M"),r("sub",[e._v("f")]),e._v(" = { intMin, .. ,0 }, N"),r("sub",[e._v("p")]),e._v(" = {1, .. , 43 }, O"),r("sub",[e._v("f")]),e._v(" = {44, .. , maxInt}}"),r("br"),e._v("\na"),r("sub",[e._v("2")]),e._v(" .. a"),r("sub",[e._v("n")]),e._v(" → aA"),r("sub",[e._v("2")]),e._v(", .. , aA"),r("sub",[e._v("n")])])]),r("p"),e._v(" "),r("li",[e._v("Schritt: Bildung von logischen Einheiten auf den verschiedenen Eingabevariablen:"),r("br"),e._v("\nEingabevariablen → logische Einheit; Bsp.:"),r("br"),e._v(" "),r("code",{pre:!0},[e._v("a"),r("sub",[e._v("1")]),e._v(", a"),r("sub",[e._v("2")]),e._v(", .. , a"),r("sub",[e._v("n")]),e._v(" → b"),r("sub",[e._v("1")]),e._v(" = {a"),r("sub",[e._v("1")]),e._v(", a"),r("sub",[e._v("3")]),e._v(", a"),r("sub",[e._v("4")]),e._v("} und b"),r("sub",[e._v("2")]),e._v(" = {a"),r("sub",[e._v("2")]),e._v(", a"),r("sub",[e._v("5")]),e._v("} usw.")])]),r("p"),e._v(" "),r("li",[e._v("Clustering der Äquivalenzklassen pro logische Einheit"),r("br"),e._v("\nÄquivalenzklassen pro logische Einheit → aggregierte Äquivalenzklassen pro logische Einheit"),r("br"),e._v(" "),r("code",{pre:!0},[e._v("bA"),r("sub",[e._v("1")]),e._v(" = {aA"),r("sub",[e._v("1")]),e._v(", aA"),r("sub",[e._v("3")]),e._v(", aA"),r("sub",[e._v("4")]),e._v("} ⇔ {M"),r("sub",[e._v("f")]),e._v(", N"),r("sub",[e._v("p")]),e._v(", O"),r("sub",[e._v("f")]),e._v(", ...} → BA"),r("sub",[e._v("1")]),e._v(" = {P, F"),r("sub",[e._v("1")]),e._v(", F"),r("sub",[e._v("2")]),e._v("}")]),r("br"),e._v("\nWobei "),r("sub",[e._v("p")]),e._v(" Pass und "),r("sub",[e._v("f")]),e._v(" Fail bedeuteut.")]),r("br")]),r("br"),e._v("\nBeispiel: Man hat eine Eingabemaske zu einer Person; (1) Dann kann man zu jedem Eingabefeld eine Äquivalenzklasse bilden. (2) Anschließend aggregiert man die Felder (z.B. Heimadressfelder, Arbeitsadressfelder, Angaben zur Krankenkasse usw.) und (3) abschließend kombiniert man die Äquivalenzklassen der aggregierten Felder."),r("p"),e._v(" "),r("p",[e._v("Ergebnis: logische Einheiten mit aggrebierten Äquivalenzklassen.")]),e._v(" "),r("p",[e._v("In den von mir eingesetzten Fällen reduzieren sich die Eingabetestfälle erheblich. Zudem entstehen auch beim paarweisen kombinieren weiterhin Standardtestfälle. Über die Testqualität kann ich nur eine Annahme treffen. Ich würde aber behaupten, dass diese nicht signifikant sinkt, denn:")]),e._v(" "),r("ol",[r("li",[e._v("die logischen Einheiten bilden meist auch Subsysteme ab und diese sollten vorab von Subsystemtests getestet werden. Die Integration wird aber weiterhin durch die Kombinationen der logischen Einheiten getestet.")]),e._v(" "),r("li",[e._v("weiterhin werden Randfälle betrachtet und die Kombination daraus getestet. Auf einer logischen Ebene handelt es sich also um Äquivalenzklassen bei den Aggregationen.")]),r("br")]),r("br"),e._v("\nFalls ihr anderer Meinung seid, lasst es mich wissen. Ansonsten viel Erfolg beim Softwaretesten!\n")])}]}}}}}}]);