(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{241:function(e,n){e.exports={body:'While I\'m working with [docker][dockerio] I use a handful of commands: build this project, run it with certain environment variables, remove the image/container. First I tried writing shell scripts to prevent me for typing this commands over and over. But the disadvantages are clear: I had quickly a bunch of scripts and I could not commit this scripts to our VCS because all this scripts were to much coupled to my setup.\nAfter a while thinking I came up with this solution: I have a base Makefile that includes a configuration file which is ignored by the VCS. This way everyone profit from the handy make commands like `make build`, `make run` etc. but all my colleagues can configure their own setting.\n\nHere the Makefile template (thanks to [@blang][blang] for the initial template)\n\n<pre>\n<code class="makefile">\ninclude env_make\nNS = your docker namespace\nVERSION ?= latest\n\nREPO = your docker repo name\nNAME = name of the image\nINSTANCE = default\n\n.PHONY: build push shell run start stop rm release\n\nbuild:\n\tdocker build -t $(NS)/$(REPO):$(VERSION) .\n\npush:\n\tdocker push $(NS)/$(REPO):$(VERSION)\n\nshell:\n\tdocker run --rm --name $(NAME)-$(INSTANCE) -i -t $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION) /bin/bash\n\nrun:\n\tdocker run --rm --name $(NAME)-$(INSTANCE) $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION)\n\nstart:\n\tdocker run -d --name $(NAME)-$(INSTANCE) $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION)\n\nstop:\n\tdocker stop $(NAME)-$(INSTANCE)\n\nrm:\n\tdocker rm $(NAME)-$(INSTANCE)\n\nrelease: build\n\tmake push -e VERSION=$(VERSION)\n\ndefault: build\n\n</code>\n</pre>\n\nand don\'t forget to place an env_make file next to your Makefile that is ignored by the VCS:\n\n<pre>\n<code class="makefile">\nPORTS = -p 8080:80\n\nVOLUMES = -v /var/log/docker:/var/log\n\nENV = \\\n  -e SOME_KEY=SOME_VALUE\n</code>\n</pre>\n\n[blang]: https://github.com/blang\n[dockerio]: https://www.docker.com\n',html:'<p>While I\'m working with <a href="https://www.docker.com">docker</a> I use a handful of commands: build this project, run it with certain environment variables, remove the image/container. First I tried writing shell scripts to prevent me for typing this commands over and over. But the disadvantages are clear: I had quickly a bunch of scripts and I could not commit this scripts to our VCS because all this scripts were to much coupled to my setup.<br>\nAfter a while thinking I came up with this solution: I have a base Makefile that includes a configuration file which is ignored by the VCS. This way everyone profit from the handy make commands like <code>make build</code>, <code>make run</code> etc. but all my colleagues can configure their own setting.</p>\n<p>Here the Makefile template (thanks to <a href="https://github.com/blang">@blang</a> for the initial template)</p>\n<pre>\n<code class="makefile">\ninclude env_make\nNS = your docker namespace\nVERSION ?= latest\n\nREPO = your docker repo name\nNAME = name of the image\nINSTANCE = default\n\n.PHONY: build push shell run start stop rm release\n\nbuild:\n\tdocker build -t $(NS)/$(REPO):$(VERSION) .\n\npush:\n\tdocker push $(NS)/$(REPO):$(VERSION)\n\nshell:\n\tdocker run --rm --name $(NAME)-$(INSTANCE) -i -t $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION) /bin/bash\n\nrun:\n\tdocker run --rm --name $(NAME)-$(INSTANCE) $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION)\n\nstart:\n\tdocker run -d --name $(NAME)-$(INSTANCE) $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION)\n\nstop:\n\tdocker stop $(NAME)-$(INSTANCE)\n\nrm:\n\tdocker rm $(NAME)-$(INSTANCE)\n\nrelease: build\n\tmake push -e VERSION=$(VERSION)\n\ndefault: build\n\n</code>\n</pre>\n<p>and don\'t forget to place an env_make file next to your Makefile that is ignored by the VCS:</p>\n<pre>\n<code class="makefile">\nPORTS = -p 8080:80\n\nVOLUMES = -v /var/log/docker:/var/log\n\nENV = \\\n  -e SOME_KEY=SOME_VALUE\n</code>\n</pre>\n',attributes:{layout:"post",title:"Speed up your docker workflow with a Makefile",date:"2014-08-31T12:10:00.000Z",categories:"docker development tools",comments:!0,_meta:{resourcePath:"/home/travis/build/Pindar/itnotes/contents/posts/2014-08-31-speed-up-your-docker-workflow-with-a-makefile.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'p\',[_vm._v("While I\'m working with "),_c(\'a\',{attrs:{"href":"https://www.docker.com"}},[_vm._v("docker")]),_vm._v(" I use a handful of commands: build this project, run it with certain environment variables, remove the image/container. First I tried writing shell scripts to prevent me for typing this commands over and over. But the disadvantages are clear: I had quickly a bunch of scripts and I could not commit this scripts to our VCS because all this scripts were to much coupled to my setup."),_c(\'br\'),_vm._v("\\nAfter a while thinking I came up with this solution: I have a base Makefile that includes a configuration file which is ignored by the VCS. This way everyone profit from the handy make commands like "),_c(\'code\',{pre:true},[_vm._v("make build")]),_vm._v(", "),_c(\'code\',{pre:true},[_vm._v("make run")]),_vm._v(" etc. but all my colleagues can configure their own setting.")]),_vm._v(" "),_c(\'p\',[_vm._v("Here the Makefile template (thanks to "),_c(\'a\',{attrs:{"href":"https://github.com/blang"}},[_vm._v("@blang")]),_vm._v(" for the initial template)")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"makefile"}},[_vm._v("\\ninclude env_make\\nNS = your docker namespace\\nVERSION ?= latest\\n\\nREPO = your docker repo name\\nNAME = name of the image\\nINSTANCE = default\\n\\n.PHONY: build push shell run start stop rm release\\n\\nbuild:\\n\\tdocker build -t $(NS)/$(REPO):$(VERSION) .\\n\\npush:\\n\\tdocker push $(NS)/$(REPO):$(VERSION)\\n\\nshell:\\n\\tdocker run --rm --name $(NAME)-$(INSTANCE) -i -t $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION) /bin/bash\\n\\nrun:\\n\\tdocker run --rm --name $(NAME)-$(INSTANCE) $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION)\\n\\nstart:\\n\\tdocker run -d --name $(NAME)-$(INSTANCE) $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION)\\n\\nstop:\\n\\tdocker stop $(NAME)-$(INSTANCE)\\n\\nrm:\\n\\tdocker rm $(NAME)-$(INSTANCE)\\n\\nrelease: build\\n\\tmake push -e VERSION=$(VERSION)\\n\\ndefault: build\\n\\n")]),_vm._v("\\n")]),_vm._v(" "),_c(\'p\',[_vm._v("and don\'t forget to place an env_make file next to your Makefile that is ignored by the VCS:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"makefile"}},[_vm._v("\\nPORTS = -p 8080:80\\n\\nVOLUMES = -v /var/log/docker:/var/log\\n\\nENV = \\\\\\n  -e SOME_KEY=SOME_VALUE\\n")]),_vm._v("\\n")])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"dynamicMarkdown"},[t("p",[e._v("While I'm working with "),t("a",{attrs:{href:"https://www.docker.com"}},[e._v("docker")]),e._v(" I use a handful of commands: build this project, run it with certain environment variables, remove the image/container. First I tried writing shell scripts to prevent me for typing this commands over and over. But the disadvantages are clear: I had quickly a bunch of scripts and I could not commit this scripts to our VCS because all this scripts were to much coupled to my setup."),t("br"),e._v("\nAfter a while thinking I came up with this solution: I have a base Makefile that includes a configuration file which is ignored by the VCS. This way everyone profit from the handy make commands like "),t("code",{pre:!0},[e._v("make build")]),e._v(", "),t("code",{pre:!0},[e._v("make run")]),e._v(" etc. but all my colleagues can configure their own setting.")]),e._v(" "),t("p",[e._v("Here the Makefile template (thanks to "),t("a",{attrs:{href:"https://github.com/blang"}},[e._v("@blang")]),e._v(" for the initial template)")]),e._v(" "),t("pre",[t("code",{pre:!0,attrs:{class:"makefile"}},[e._v("\ninclude env_make\nNS = your docker namespace\nVERSION ?= latest\n\nREPO = your docker repo name\nNAME = name of the image\nINSTANCE = default\n\n.PHONY: build push shell run start stop rm release\n\nbuild:\n\tdocker build -t $(NS)/$(REPO):$(VERSION) .\n\npush:\n\tdocker push $(NS)/$(REPO):$(VERSION)\n\nshell:\n\tdocker run --rm --name $(NAME)-$(INSTANCE) -i -t $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION) /bin/bash\n\nrun:\n\tdocker run --rm --name $(NAME)-$(INSTANCE) $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION)\n\nstart:\n\tdocker run -d --name $(NAME)-$(INSTANCE) $(PORTS) $(VOLUMES) $(ENV) $(NS)/$(REPO):$(VERSION)\n\nstop:\n\tdocker stop $(NAME)-$(INSTANCE)\n\nrm:\n\tdocker rm $(NAME)-$(INSTANCE)\n\nrelease: build\n\tmake push -e VERSION=$(VERSION)\n\ndefault: build\n\n")]),e._v("\n")]),e._v(" "),t("p",[e._v("and don't forget to place an env_make file next to your Makefile that is ignored by the VCS:")]),e._v(" "),t("pre",[t("code",{pre:!0,attrs:{class:"makefile"}},[e._v("\nPORTS = -p 8080:80\n\nVOLUMES = -v /var/log/docker:/var/log\n\nENV = \\\n  -e SOME_KEY=SOME_VALUE\n")]),e._v("\n")])])}]}}}}}}]);