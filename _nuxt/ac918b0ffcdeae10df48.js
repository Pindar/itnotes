(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{213:function(e,n){e.exports={body:'<h2>Auswirkungen von Altlasten auf die Neuentwicklung von Features.</h2><br />\nAltlasten in Softwaresystemen sind beinahe immer alte Anforderungen, die von anderen Personen vor l&auml;ngerer Zeit umgesetzt wurden. Trotz Dokumentationen in Form von JIRA-Tickets, WIKI-Eintr&auml;gen und Testdokumentation ist es sowohl f&uuml;r Softwareentwickler als auch f&uuml;r das Anforderungsmanagement kaum m&ouml;glich all diese Informationen in ad&auml;quater Zeit auszuwerten, um ein neues Feature kosteng&uuml;nstig liefern zu k&ouml;nnen.</p>\n<p>Die in der Praxis g&auml;ngige Herangehensweise, um dieses Problem zu l&ouml;sen ist daher einfach nachzuvollziehen: Man versucht m&ouml;glichst nichts an der bestehenden Funktionalit&auml;t zu &auml;ndern (d.h. der Softwareentwickler versucht bestehenden Code nicht zu ver&auml;ndern) und f&uuml;gt seine neuen &Auml;nderungen einfach hinzu. Dieses Vorgehen funktioniert bei den ersten &Auml;nderungsanfragen auch wie gew&uuml;nscht. Nach einiger Zeit stellt sich jedoch eine Situation ein, die es unabdingbar macht bestehenden Code anzufassen. Sp&auml;testens, wenn neue Anforderungen im Widerspruch zu alten stehen. Dies ist der Knackpunkt an dem nun auch alle alten &Uuml;berlegungen mit bedacht werden m&uuml;ssten, um den &Uuml;berblick &uuml;ber das System beibehalten zu k&ouml;nnen. Das Produktrisiko steigt enorm an und die QA-Phase verl&auml;ngert sich deutlich st&auml;rker als nur linear (alte Anforderungen m&uuml;ssen "erforscht" und intensiv nachgetestet werden).<br />\nFolge: Die Kosten f&uuml;r Neuentwicklungen steigen rasant an, jedoch sind die eben genannten Punkte den Auftraggebern oft nicht transparent.</p>\n<h2>Warum man ein System nicht vorab so planen kann, dass es auf alle Eventualit&auml;ten erweiterbar ist.</h2><br />\nIn klassischer Softwareentwicklung ist eine Strategie gegen das Altlastenproblem die Software so zu planen, dass das Altlastenproblem nie entstehen wird. Das hei&szlig;t, dass die Software ohne &Auml;nderung bestehender Softwareteile ewig erweiterbar bleibt. Dass dies ein reiner Wunschgedanke bleibt, ist sp&auml;testens mit einer fachlichen Anforderung belegt, die im Widerspruch zu bestehenden, und bereits umgesetzten Anforderungen steht. Aus Gesch&auml;ftsstrategischer Sicht ist es einleuchtend, dass eine solche Situation in einer schnelllebigen Welt sehr oft eintreten kann. Einen statischen Plan zu entwickeln steht auch im gravierenden Widerspruch zur dynamischen Komplexit&auml;t, die die gesch&auml;ftliche Situation hier deutlich besser abbildet (siehe auch "Scaling Lean &amp; Agile Development: Thinking and Organizational Tools for Large-Scale Scrum: Successful Large, Multisite and Offshore Products with Large-scale Scrum", Craig Larmen und Bas Vodde).</p>\n<h2>Wie man sich von Altlasten befreit und Agilit&auml;t erreicht.</h2><br />\nWie aus dem ersten Punkt hervorgeht ist es sehr einfach neue Altlasten aufzubauen. Welche L&ouml;sungen schl&auml;gt nun die Wissenschaft und Praxis vor, um das Altlastenproblem zu l&ouml;sen?</p>\n<p>Die einstimmige Meinung unter agilen Softwareentwicklern ist, sich der Tatsache bewusst zu werden. Wenn man sich im klaren dar&uuml;ber ist, dass Softwaresysteme &uuml;ber die Zeit fehlerhaft und schwergewichtig werden, kann man Ma&szlig;nahmen umsetzen, die das kontinuierlich abmildern.<br />\nDazu geh&ouml;ren folgende Punkte:</p>\n<p>1) Testgetriebene Softwareentwicklung (Test-Driven Development, Jeff Langr, http://pragprog.com/magazines/2011-11/testdriven-development, Practices for Scaling Lean and Agile Development: Large, Multisite, and Offshore Product Development with Large-Scale Scrum, Craig Larmen und Bas Vodde)<br />\n2) Spezifikationen anhand von Beispielen (Specification by Example, Gojko Adzic)<br />\n3) Kontinuierliche Upgrades von eingebundener Fremdsoftware<br />\n4) Die einfachste L&ouml;sung umzusetzen, die die Anforderung erf&uuml;llt (&ldquo;You Ain&rsquo;t Gonna Need It&rdquo;, http://de.wikipedia.org/wiki/YAGNI)</p>\n<p>Wie &auml;u&szlig;ern sich diese Ma&szlig;nahmen mittel- bzw. langfristig aus monet&auml;rer Sicht?</p>\n<p>Ad 1) Testgetriebene Softwareentwicklung ist trotz seines Namens nicht gleichzusetzen mit Software zu testen ("Test-first coding is not a testing technique", Ward Cunningham). Vielmehr f&uuml;hrt es implizit zu einer jederzeit &auml;nderbaren Software, durch das kontinuierliche schreiben von automatischen Tests und dem noch wichtigerem kontinuierlichem Refactoring des neu geschriebenen Codes. Zusammengefasst: Die Kosten f&uuml;r Neuentwicklungen bleiben &uuml;ber die Zeit relativ konstant.</p>\n<p>Ad 2) Wenn Anforderungen mit klaren Beispielen dokumentiert sind, werden diese schneller verstanden. Missverst&auml;ndnisse werden reduziert und die r&uuml;ckblickende Information was umgesetzt wurde ist klarer. Ebenso lassen sich Beispiele einfach automatisiert testen, wodurch Anforderungen kontinuierlich qualitativ gesichert werden k&ouml;nnen, ohne zus&auml;tzlichen Kostenaufwand &uuml;ber die Zeit.</p>\n<p>Ad 3) Veraltete Fremdsoftware f&uuml;hrt langfristig dazu, dass keine Softwareentwickler mehr gefunden werden, die mit diesen Versionen arbeiten k&ouml;nnen. Das Umsetzen neuer Features wird bei alter Fremdsoftware also verl&auml;ngert, wodurch die Kosten steigen.</p>\n<p>Ad 4) Das Feature wird so umgesetzt wie gefordert, aber auch nicht mehr. Der Aufwand wird auf das n&ouml;tigste reduziert und Kosten f&uuml;r Planungs-Overhead werden obsolet. Der Return of Investment steigt.</p>\n<h2>Warum das eine kontinuierliche T&auml;tigkeit bleiben muss</h2><br />\nRefactoring ist keine T&auml;tigkeit, die in einem Entwicklungszyklus erledigt werden kann, sondern es ist eine kontinuierliche T&auml;tigkeit. Man kann diese Aufgabe am besten mit der B&uuml;roreinigung vergleichen: W&uuml;rde man das B&uuml;ro nur einmal im Jahr reinigen, h&auml;tte man auch hier einen deutlich h&ouml;heren Aufwand und das Unbehagen in der &uuml;brigen Zeit w&auml;re bei allen Beteiligten nach kurzer Zeit sehr gro&szlig;.</p>\n',html:'<h2>Auswirkungen von Altlasten auf die Neuentwicklung von Features.</h2><br />\nAltlasten in Softwaresystemen sind beinahe immer alte Anforderungen, die von anderen Personen vor l&auml;ngerer Zeit umgesetzt wurden. Trotz Dokumentationen in Form von JIRA-Tickets, WIKI-Eintr&auml;gen und Testdokumentation ist es sowohl f&uuml;r Softwareentwickler als auch f&uuml;r das Anforderungsmanagement kaum m&ouml;glich all diese Informationen in ad&auml;quater Zeit auszuwerten, um ein neues Feature kosteng&uuml;nstig liefern zu k&ouml;nnen.</p>\n<p>Die in der Praxis g&auml;ngige Herangehensweise, um dieses Problem zu l&ouml;sen ist daher einfach nachzuvollziehen: Man versucht m&ouml;glichst nichts an der bestehenden Funktionalit&auml;t zu &auml;ndern (d.h. der Softwareentwickler versucht bestehenden Code nicht zu ver&auml;ndern) und f&uuml;gt seine neuen &Auml;nderungen einfach hinzu. Dieses Vorgehen funktioniert bei den ersten &Auml;nderungsanfragen auch wie gew&uuml;nscht. Nach einiger Zeit stellt sich jedoch eine Situation ein, die es unabdingbar macht bestehenden Code anzufassen. Sp&auml;testens, wenn neue Anforderungen im Widerspruch zu alten stehen. Dies ist der Knackpunkt an dem nun auch alle alten &Uuml;berlegungen mit bedacht werden m&uuml;ssten, um den &Uuml;berblick &uuml;ber das System beibehalten zu k&ouml;nnen. Das Produktrisiko steigt enorm an und die QA-Phase verl&auml;ngert sich deutlich st&auml;rker als nur linear (alte Anforderungen m&uuml;ssen "erforscht" und intensiv nachgetestet werden).<br />\nFolge: Die Kosten f&uuml;r Neuentwicklungen steigen rasant an, jedoch sind die eben genannten Punkte den Auftraggebern oft nicht transparent.</p>\n<h2>Warum man ein System nicht vorab so planen kann, dass es auf alle Eventualit&auml;ten erweiterbar ist.</h2><br />\nIn klassischer Softwareentwicklung ist eine Strategie gegen das Altlastenproblem die Software so zu planen, dass das Altlastenproblem nie entstehen wird. Das hei&szlig;t, dass die Software ohne &Auml;nderung bestehender Softwareteile ewig erweiterbar bleibt. Dass dies ein reiner Wunschgedanke bleibt, ist sp&auml;testens mit einer fachlichen Anforderung belegt, die im Widerspruch zu bestehenden, und bereits umgesetzten Anforderungen steht. Aus Gesch&auml;ftsstrategischer Sicht ist es einleuchtend, dass eine solche Situation in einer schnelllebigen Welt sehr oft eintreten kann. Einen statischen Plan zu entwickeln steht auch im gravierenden Widerspruch zur dynamischen Komplexit&auml;t, die die gesch&auml;ftliche Situation hier deutlich besser abbildet (siehe auch "Scaling Lean &amp; Agile Development: Thinking and Organizational Tools for Large-Scale Scrum: Successful Large, Multisite and Offshore Products with Large-scale Scrum", Craig Larmen und Bas Vodde).</p>\n<h2>Wie man sich von Altlasten befreit und Agilit&auml;t erreicht.</h2><br />\nWie aus dem ersten Punkt hervorgeht ist es sehr einfach neue Altlasten aufzubauen. Welche L&ouml;sungen schl&auml;gt nun die Wissenschaft und Praxis vor, um das Altlastenproblem zu l&ouml;sen?</p>\n<p>Die einstimmige Meinung unter agilen Softwareentwicklern ist, sich der Tatsache bewusst zu werden. Wenn man sich im klaren dar&uuml;ber ist, dass Softwaresysteme &uuml;ber die Zeit fehlerhaft und schwergewichtig werden, kann man Ma&szlig;nahmen umsetzen, die das kontinuierlich abmildern.<br />\nDazu geh&ouml;ren folgende Punkte:</p>\n<p>1) Testgetriebene Softwareentwicklung (Test-Driven Development, Jeff Langr, http://pragprog.com/magazines/2011-11/testdriven-development, Practices for Scaling Lean and Agile Development: Large, Multisite, and Offshore Product Development with Large-Scale Scrum, Craig Larmen und Bas Vodde)<br />\n2) Spezifikationen anhand von Beispielen (Specification by Example, Gojko Adzic)<br />\n3) Kontinuierliche Upgrades von eingebundener Fremdsoftware<br />\n4) Die einfachste L&ouml;sung umzusetzen, die die Anforderung erf&uuml;llt (&ldquo;You Ain&rsquo;t Gonna Need It&rdquo;, http://de.wikipedia.org/wiki/YAGNI)</p>\n<p>Wie &auml;u&szlig;ern sich diese Ma&szlig;nahmen mittel- bzw. langfristig aus monet&auml;rer Sicht?</p>\n<p>Ad 1) Testgetriebene Softwareentwicklung ist trotz seines Namens nicht gleichzusetzen mit Software zu testen ("Test-first coding is not a testing technique", Ward Cunningham). Vielmehr f&uuml;hrt es implizit zu einer jederzeit &auml;nderbaren Software, durch das kontinuierliche schreiben von automatischen Tests und dem noch wichtigerem kontinuierlichem Refactoring des neu geschriebenen Codes. Zusammengefasst: Die Kosten f&uuml;r Neuentwicklungen bleiben &uuml;ber die Zeit relativ konstant.</p>\n<p>Ad 2) Wenn Anforderungen mit klaren Beispielen dokumentiert sind, werden diese schneller verstanden. Missverst&auml;ndnisse werden reduziert und die r&uuml;ckblickende Information was umgesetzt wurde ist klarer. Ebenso lassen sich Beispiele einfach automatisiert testen, wodurch Anforderungen kontinuierlich qualitativ gesichert werden k&ouml;nnen, ohne zus&auml;tzlichen Kostenaufwand &uuml;ber die Zeit.</p>\n<p>Ad 3) Veraltete Fremdsoftware f&uuml;hrt langfristig dazu, dass keine Softwareentwickler mehr gefunden werden, die mit diesen Versionen arbeiten k&ouml;nnen. Das Umsetzen neuer Features wird bei alter Fremdsoftware also verl&auml;ngert, wodurch die Kosten steigen.</p>\n<p>Ad 4) Das Feature wird so umgesetzt wie gefordert, aber auch nicht mehr. Der Aufwand wird auf das n&ouml;tigste reduziert und Kosten f&uuml;r Planungs-Overhead werden obsolet. Der Return of Investment steigt.</p>\n<h2>Warum das eine kontinuierliche T&auml;tigkeit bleiben muss</h2><br />\nRefactoring ist keine T&auml;tigkeit, die in einem Entwicklungszyklus erledigt werden kann, sondern es ist eine kontinuierliche T&auml;tigkeit. Man kann diese Aufgabe am besten mit der B&uuml;roreinigung vergleichen: W&uuml;rde man das B&uuml;ro nur einmal im Jahr reinigen, h&auml;tte man auch hier einen deutlich h&ouml;heren Aufwand und das Unbehagen in der &uuml;brigen Zeit w&auml;re bei allen Beteiligten nach kurzer Zeit sehr gro&szlig;.</p>\n',attributes:{layout:"post",status:"publish",published:!0,title:"Refactoring",author:"Simon Dittlmann",author_login:"Simon",author_email:"simon.dittlmann@itnotes.de",author_url:"http://www.itnotes.de",wordpress_id:130,wordpress_url:"http://www.pindarsign.de/itnotes/?p=130",date:"2012-04-10 10:10:15 +0200",date_gmt:"2012-04-10 08:10:15 +0200",categories:["articles"],tags:["refactoring","programming","process"],comments:[],_meta:{resourcePath:"/home/travis/build/Pindar/itnotes/contents/posts/2012-04-10-refactoring.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h2\',[_vm._v("Auswirkungen von Altlasten auf die Neuentwicklung von Features.")]),_c(\'br\'),_vm._v("\\nAltlasten in Softwaresystemen sind beinahe immer alte Anforderungen, die von anderen Personen vor längerer Zeit umgesetzt wurden. Trotz Dokumentationen in Form von JIRA-Tickets, WIKI-Einträgen und Testdokumentation ist es sowohl für Softwareentwickler als auch für das Anforderungsmanagement kaum möglich all diese Informationen in adäquater Zeit auszuwerten, um ein neues Feature kostengünstig liefern zu können."),_c(\'p\'),_vm._v(" "),_c(\'p\',[_vm._v("Die in der Praxis gängige Herangehensweise, um dieses Problem zu lösen ist daher einfach nachzuvollziehen: Man versucht möglichst nichts an der bestehenden Funktionalität zu ändern (d.h. der Softwareentwickler versucht bestehenden Code nicht zu verändern) und fügt seine neuen Änderungen einfach hinzu. Dieses Vorgehen funktioniert bei den ersten Änderungsanfragen auch wie gewünscht. Nach einiger Zeit stellt sich jedoch eine Situation ein, die es unabdingbar macht bestehenden Code anzufassen. Spätestens, wenn neue Anforderungen im Widerspruch zu alten stehen. Dies ist der Knackpunkt an dem nun auch alle alten Überlegungen mit bedacht werden müssten, um den Überblick über das System beibehalten zu können. Das Produktrisiko steigt enorm an und die QA-Phase verlängert sich deutlich stärker als nur linear (alte Anforderungen müssen \\"erforscht\\" und intensiv nachgetestet werden)."),_c(\'br\'),_vm._v("\\nFolge: Die Kosten für Neuentwicklungen steigen rasant an, jedoch sind die eben genannten Punkte den Auftraggebern oft nicht transparent.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Warum man ein System nicht vorab so planen kann, dass es auf alle Eventualitäten erweiterbar ist.")]),_c(\'br\'),_vm._v("\\nIn klassischer Softwareentwicklung ist eine Strategie gegen das Altlastenproblem die Software so zu planen, dass das Altlastenproblem nie entstehen wird. Das heißt, dass die Software ohne Änderung bestehender Softwareteile ewig erweiterbar bleibt. Dass dies ein reiner Wunschgedanke bleibt, ist spätestens mit einer fachlichen Anforderung belegt, die im Widerspruch zu bestehenden, und bereits umgesetzten Anforderungen steht. Aus Geschäftsstrategischer Sicht ist es einleuchtend, dass eine solche Situation in einer schnelllebigen Welt sehr oft eintreten kann. Einen statischen Plan zu entwickeln steht auch im gravierenden Widerspruch zur dynamischen Komplexität, die die geschäftliche Situation hier deutlich besser abbildet (siehe auch \\"Scaling Lean & Agile Development: Thinking and Organizational Tools for Large-Scale Scrum: Successful Large, Multisite and Offshore Products with Large-scale Scrum\\", Craig Larmen und Bas Vodde)."),_c(\'p\'),_vm._v(" "),_c(\'h2\',[_vm._v("Wie man sich von Altlasten befreit und Agilität erreicht.")]),_c(\'br\'),_vm._v("\\nWie aus dem ersten Punkt hervorgeht ist es sehr einfach neue Altlasten aufzubauen. Welche Lösungen schlägt nun die Wissenschaft und Praxis vor, um das Altlastenproblem zu lösen?"),_c(\'p\'),_vm._v(" "),_c(\'p\',[_vm._v("Die einstimmige Meinung unter agilen Softwareentwicklern ist, sich der Tatsache bewusst zu werden. Wenn man sich im klaren darüber ist, dass Softwaresysteme über die Zeit fehlerhaft und schwergewichtig werden, kann man Maßnahmen umsetzen, die das kontinuierlich abmildern."),_c(\'br\'),_vm._v("\\nDazu gehören folgende Punkte:")]),_vm._v(" "),_c(\'p\',[_vm._v("1) Testgetriebene Softwareentwicklung (Test-Driven Development, Jeff Langr, http://pragprog.com/magazines/2011-11/testdriven-development, Practices for Scaling Lean and Agile Development: Large, Multisite, and Offshore Product Development with Large-Scale Scrum, Craig Larmen und Bas Vodde)"),_c(\'br\'),_vm._v("\\n2) Spezifikationen anhand von Beispielen (Specification by Example, Gojko Adzic)"),_c(\'br\'),_vm._v("\\n3) Kontinuierliche Upgrades von eingebundener Fremdsoftware"),_c(\'br\'),_vm._v("\\n4) Die einfachste Lösung umzusetzen, die die Anforderung erfüllt (“You Ain’t Gonna Need It”, http://de.wikipedia.org/wiki/YAGNI)")]),_vm._v(" "),_c(\'p\',[_vm._v("Wie äußern sich diese Maßnahmen mittel- bzw. langfristig aus monetärer Sicht?")]),_vm._v(" "),_c(\'p\',[_vm._v("Ad 1) Testgetriebene Softwareentwicklung ist trotz seines Namens nicht gleichzusetzen mit Software zu testen (\\"Test-first coding is not a testing technique\\", Ward Cunningham). Vielmehr führt es implizit zu einer jederzeit änderbaren Software, durch das kontinuierliche schreiben von automatischen Tests und dem noch wichtigerem kontinuierlichem Refactoring des neu geschriebenen Codes. Zusammengefasst: Die Kosten für Neuentwicklungen bleiben über die Zeit relativ konstant.")]),_vm._v(" "),_c(\'p\',[_vm._v("Ad 2) Wenn Anforderungen mit klaren Beispielen dokumentiert sind, werden diese schneller verstanden. Missverständnisse werden reduziert und die rückblickende Information was umgesetzt wurde ist klarer. Ebenso lassen sich Beispiele einfach automatisiert testen, wodurch Anforderungen kontinuierlich qualitativ gesichert werden können, ohne zusätzlichen Kostenaufwand über die Zeit.")]),_vm._v(" "),_c(\'p\',[_vm._v("Ad 3) Veraltete Fremdsoftware führt langfristig dazu, dass keine Softwareentwickler mehr gefunden werden, die mit diesen Versionen arbeiten können. Das Umsetzen neuer Features wird bei alter Fremdsoftware also verlängert, wodurch die Kosten steigen.")]),_vm._v(" "),_c(\'p\',[_vm._v("Ad 4) Das Feature wird so umgesetzt wie gefordert, aber auch nicht mehr. Der Aufwand wird auf das nötigste reduziert und Kosten für Planungs-Overhead werden obsolet. Der Return of Investment steigt.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Warum das eine kontinuierliche Tätigkeit bleiben muss")]),_c(\'br\'),_vm._v("\\nRefactoring ist keine Tätigkeit, die in einem Entwicklungszyklus erledigt werden kann, sondern es ist eine kontinuierliche Tätigkeit. Man kann diese Aufgabe am besten mit der Büroreinigung vergleichen: Würde man das Büro nur einmal im Jahr reinigen, hätte man auch hier einen deutlich höheren Aufwand und das Unbehagen in der übrigen Zeit wäre bei allen Beteiligten nach kurzer Zeit sehr groß."),_c(\'p\')]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"dynamicMarkdown"},[t("h2",[e._v("Auswirkungen von Altlasten auf die Neuentwicklung von Features.")]),t("br"),e._v("\nAltlasten in Softwaresystemen sind beinahe immer alte Anforderungen, die von anderen Personen vor längerer Zeit umgesetzt wurden. Trotz Dokumentationen in Form von JIRA-Tickets, WIKI-Einträgen und Testdokumentation ist es sowohl für Softwareentwickler als auch für das Anforderungsmanagement kaum möglich all diese Informationen in adäquater Zeit auszuwerten, um ein neues Feature kostengünstig liefern zu können."),t("p"),e._v(" "),t("p",[e._v('Die in der Praxis gängige Herangehensweise, um dieses Problem zu lösen ist daher einfach nachzuvollziehen: Man versucht möglichst nichts an der bestehenden Funktionalität zu ändern (d.h. der Softwareentwickler versucht bestehenden Code nicht zu verändern) und fügt seine neuen Änderungen einfach hinzu. Dieses Vorgehen funktioniert bei den ersten Änderungsanfragen auch wie gewünscht. Nach einiger Zeit stellt sich jedoch eine Situation ein, die es unabdingbar macht bestehenden Code anzufassen. Spätestens, wenn neue Anforderungen im Widerspruch zu alten stehen. Dies ist der Knackpunkt an dem nun auch alle alten Überlegungen mit bedacht werden müssten, um den Überblick über das System beibehalten zu können. Das Produktrisiko steigt enorm an und die QA-Phase verlängert sich deutlich stärker als nur linear (alte Anforderungen müssen "erforscht" und intensiv nachgetestet werden).'),t("br"),e._v("\nFolge: Die Kosten für Neuentwicklungen steigen rasant an, jedoch sind die eben genannten Punkte den Auftraggebern oft nicht transparent.")]),e._v(" "),t("h2",[e._v("Warum man ein System nicht vorab so planen kann, dass es auf alle Eventualitäten erweiterbar ist.")]),t("br"),e._v('\nIn klassischer Softwareentwicklung ist eine Strategie gegen das Altlastenproblem die Software so zu planen, dass das Altlastenproblem nie entstehen wird. Das heißt, dass die Software ohne Änderung bestehender Softwareteile ewig erweiterbar bleibt. Dass dies ein reiner Wunschgedanke bleibt, ist spätestens mit einer fachlichen Anforderung belegt, die im Widerspruch zu bestehenden, und bereits umgesetzten Anforderungen steht. Aus Geschäftsstrategischer Sicht ist es einleuchtend, dass eine solche Situation in einer schnelllebigen Welt sehr oft eintreten kann. Einen statischen Plan zu entwickeln steht auch im gravierenden Widerspruch zur dynamischen Komplexität, die die geschäftliche Situation hier deutlich besser abbildet (siehe auch "Scaling Lean & Agile Development: Thinking and Organizational Tools for Large-Scale Scrum: Successful Large, Multisite and Offshore Products with Large-scale Scrum", Craig Larmen und Bas Vodde).'),t("p"),e._v(" "),t("h2",[e._v("Wie man sich von Altlasten befreit und Agilität erreicht.")]),t("br"),e._v("\nWie aus dem ersten Punkt hervorgeht ist es sehr einfach neue Altlasten aufzubauen. Welche Lösungen schlägt nun die Wissenschaft und Praxis vor, um das Altlastenproblem zu lösen?"),t("p"),e._v(" "),t("p",[e._v("Die einstimmige Meinung unter agilen Softwareentwicklern ist, sich der Tatsache bewusst zu werden. Wenn man sich im klaren darüber ist, dass Softwaresysteme über die Zeit fehlerhaft und schwergewichtig werden, kann man Maßnahmen umsetzen, die das kontinuierlich abmildern."),t("br"),e._v("\nDazu gehören folgende Punkte:")]),e._v(" "),t("p",[e._v("1) Testgetriebene Softwareentwicklung (Test-Driven Development, Jeff Langr, http://pragprog.com/magazines/2011-11/testdriven-development, Practices for Scaling Lean and Agile Development: Large, Multisite, and Offshore Product Development with Large-Scale Scrum, Craig Larmen und Bas Vodde)"),t("br"),e._v("\n2) Spezifikationen anhand von Beispielen (Specification by Example, Gojko Adzic)"),t("br"),e._v("\n3) Kontinuierliche Upgrades von eingebundener Fremdsoftware"),t("br"),e._v("\n4) Die einfachste Lösung umzusetzen, die die Anforderung erfüllt (“You Ain’t Gonna Need It”, http://de.wikipedia.org/wiki/YAGNI)")]),e._v(" "),t("p",[e._v("Wie äußern sich diese Maßnahmen mittel- bzw. langfristig aus monetärer Sicht?")]),e._v(" "),t("p",[e._v('Ad 1) Testgetriebene Softwareentwicklung ist trotz seines Namens nicht gleichzusetzen mit Software zu testen ("Test-first coding is not a testing technique", Ward Cunningham). Vielmehr führt es implizit zu einer jederzeit änderbaren Software, durch das kontinuierliche schreiben von automatischen Tests und dem noch wichtigerem kontinuierlichem Refactoring des neu geschriebenen Codes. Zusammengefasst: Die Kosten für Neuentwicklungen bleiben über die Zeit relativ konstant.')]),e._v(" "),t("p",[e._v("Ad 2) Wenn Anforderungen mit klaren Beispielen dokumentiert sind, werden diese schneller verstanden. Missverständnisse werden reduziert und die rückblickende Information was umgesetzt wurde ist klarer. Ebenso lassen sich Beispiele einfach automatisiert testen, wodurch Anforderungen kontinuierlich qualitativ gesichert werden können, ohne zusätzlichen Kostenaufwand über die Zeit.")]),e._v(" "),t("p",[e._v("Ad 3) Veraltete Fremdsoftware führt langfristig dazu, dass keine Softwareentwickler mehr gefunden werden, die mit diesen Versionen arbeiten können. Das Umsetzen neuer Features wird bei alter Fremdsoftware also verlängert, wodurch die Kosten steigen.")]),e._v(" "),t("p",[e._v("Ad 4) Das Feature wird so umgesetzt wie gefordert, aber auch nicht mehr. Der Aufwand wird auf das nötigste reduziert und Kosten für Planungs-Overhead werden obsolet. Der Return of Investment steigt.")]),e._v(" "),t("h2",[e._v("Warum das eine kontinuierliche Tätigkeit bleiben muss")]),t("br"),e._v("\nRefactoring ist keine Tätigkeit, die in einem Entwicklungszyklus erledigt werden kann, sondern es ist eine kontinuierliche Tätigkeit. Man kann diese Aufgabe am besten mit der Büroreinigung vergleichen: Würde man das Büro nur einmal im Jahr reinigen, hätte man auch hier einen deutlich höheren Aufwand und das Unbehagen in der übrigen Zeit wäre bei allen Beteiligten nach kurzer Zeit sehr groß."),t("p")])}]}}}}}}]);