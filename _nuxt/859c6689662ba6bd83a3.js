(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{243:function(e,t){e.exports={body:"After one year working with AWS Cloudformation templates I've changed the way how the templates are structured. When I started I thought it might be a good idea to have everything that belongs to each other in one file. This means that this file includes Route53 entries, AutoScaling, Alarms, etc. Then I extracted Alarms and DNS entries but still Elastic Load Balancer, Security Groups and Auto Scaling Groups were defined in the same file. \n\nToday I think that it's better to split it into logical layers. For example I decided to have a Domain-Name Layer that defines all Route53 domain record sets. Then I have a layer that defines an environment without volatile items (e.g. Auto Scaling Groups) but with Elastic Load Balancer, Security Groups etc. Then I have a Template for each application cluster where a cluster consists of an AutoScalingGroup, a SecurityGroup, some Alarms etc. Furthermore alarms are defined again in a separate file and this is created as a referenced Stack (AWS::CloudFormation::Stack). With this approach it's very handy to deploy new applications by adding new cluster stacks. Furthermore if I'd like to change something on an ELB I don't need to fear that I break something on the application.\n\n![Cloudformation Layer illustration](/cloudformation-layer.svg)\n",html:"<p>After one year working with AWS Cloudformation templates I've changed the way how the templates are structured. When I started I thought it might be a good idea to have everything that belongs to each other in one file. This means that this file includes Route53 entries, AutoScaling, Alarms, etc. Then I extracted Alarms and DNS entries but still Elastic Load Balancer, Security Groups and Auto Scaling Groups were defined in the same file.</p>\n<p>Today I think that it's better to split it into logical layers. For example I decided to have a Domain-Name Layer that defines all Route53 domain record sets. Then I have a layer that defines an environment without volatile items (e.g. Auto Scaling Groups) but with Elastic Load Balancer, Security Groups etc. Then I have a Template for each application cluster where a cluster consists of an AutoScalingGroup, a SecurityGroup, some Alarms etc. Furthermore alarms are defined again in a separate file and this is created as a referenced Stack (AWS::CloudFormation::Stack). With this approach it's very handy to deploy new applications by adding new cluster stacks. Furthermore if I'd like to change something on an ELB I don't need to fear that I break something on the application.</p>\n<p><img src=\"/cloudformation-layer.svg\" alt=\"Cloudformation Layer illustration\"></p>\n",attributes:{layout:"post",title:"One possible way to structure Cloudformation templates",date:"2014-09-11T21:08:00.000Z",categories:"cloudformation development tools aws",comments:!0,_meta:{resourcePath:"/home/travis/build/Pindar/itnotes/contents/posts/2014-09-11-cloudformation-template-structure.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'p\',[_vm._v("After one year working with AWS Cloudformation templates I\'ve changed the way how the templates are structured. When I started I thought it might be a good idea to have everything that belongs to each other in one file. This means that this file includes Route53 entries, AutoScaling, Alarms, etc. Then I extracted Alarms and DNS entries but still Elastic Load Balancer, Security Groups and Auto Scaling Groups were defined in the same file.")]),_vm._v(" "),_c(\'p\',[_vm._v("Today I think that it\'s better to split it into logical layers. For example I decided to have a Domain-Name Layer that defines all Route53 domain record sets. Then I have a layer that defines an environment without volatile items (e.g. Auto Scaling Groups) but with Elastic Load Balancer, Security Groups etc. Then I have a Template for each application cluster where a cluster consists of an AutoScalingGroup, a SecurityGroup, some Alarms etc. Furthermore alarms are defined again in a separate file and this is created as a referenced Stack (AWS::CloudFormation::Stack). With this approach it\'s very handy to deploy new applications by adding new cluster stacks. Furthermore if I\'d like to change something on an ELB I don\'t need to fear that I break something on the application.")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"/cloudformation-layer.svg","alt":"Cloudformation Layer illustration"}})])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"dynamicMarkdown"},[t("p",[this._v("After one year working with AWS Cloudformation templates I've changed the way how the templates are structured. When I started I thought it might be a good idea to have everything that belongs to each other in one file. This means that this file includes Route53 entries, AutoScaling, Alarms, etc. Then I extracted Alarms and DNS entries but still Elastic Load Balancer, Security Groups and Auto Scaling Groups were defined in the same file.")]),this._v(" "),t("p",[this._v("Today I think that it's better to split it into logical layers. For example I decided to have a Domain-Name Layer that defines all Route53 domain record sets. Then I have a layer that defines an environment without volatile items (e.g. Auto Scaling Groups) but with Elastic Load Balancer, Security Groups etc. Then I have a Template for each application cluster where a cluster consists of an AutoScalingGroup, a SecurityGroup, some Alarms etc. Furthermore alarms are defined again in a separate file and this is created as a referenced Stack (AWS::CloudFormation::Stack). With this approach it's very handy to deploy new applications by adding new cluster stacks. Furthermore if I'd like to change something on an ELB I don't need to fear that I break something on the application.")]),this._v(" "),t("p",[t("img",{attrs:{src:"/cloudformation-layer.svg",alt:"Cloudformation Layer illustration"}})])])}]}}}}}}]);